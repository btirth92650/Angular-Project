import { NgModule, Optional, SkipSelf, } from "@angular/core";
import { HTTP_INTERCEPTORS } from "@angular/common/http";
import { JwtInterceptor } from "./jwt.interceptor";
import { JWT_OPTIONS } from "./jwtoptions.token";
import { JwtHelperService } from "./jwthelper.service";
import * as ɵngcc0 from '@angular/core';
export class JwtModule {
    constructor(parentModule) {
        if (parentModule) {
            throw new Error("JwtModule is already loaded. It should only be imported in your application's main module.");
        }
    }
    static forRoot(options) {
        return {
            ngModule: JwtModule,
            providers: [
                {
                    provide: HTTP_INTERCEPTORS,
                    useClass: JwtInterceptor,
                    multi: true,
                },
                options.jwtOptionsProvider || {
                    provide: JWT_OPTIONS,
                    useValue: options.config,
                },
                JwtHelperService,
            ],
        };
    }
}
JwtModule.ɵfac = function JwtModule_Factory(t) { return new (t || JwtModule)(ɵngcc0.ɵɵinject(JwtModule, 12)); };
JwtModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: JwtModule });
JwtModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({});
JwtModule.ctorParameters = () => [
    { type: JwtModule, decorators: [{ type: Optional }, { type: SkipSelf }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(JwtModule, [{
        type: NgModule
    }], function () { return [{ type: JwtModule, decorators: [{
                type: Optional
            }, {
                type: SkipSelf
            }] }]; }, null); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ndWxhci1qd3QubW9kdWxlLmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9hbmd1bGFyLWp3dC9zcmMvbGliL2FuZ3VsYXItand0Lm1vZHVsZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsUUFBUSxFQUVSLFFBQVEsRUFDUixRQUFRLEdBRVQsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFlLGlCQUFpQixFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDdEUsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQ25ELE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUNqRCxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQzs7QUFvQnZELE1BQU0sT0FBTyxTQUFTO0FBQ3RCLElBQUUsWUFBb0MsWUFBdUI7QUFDN0QsUUFBSSxJQUFJLFlBQVksRUFBRTtBQUN0QixZQUFNLE1BQU0sSUFBSSxLQUFLLENBQ2IsNEZBQTRGLENBQzdGLENBQUM7QUFDUixTQUFLO0FBQ0wsSUFBRSxDQUFDO0FBQ0gsSUFBRSxNQUFNLENBQUMsT0FBTyxDQUFDLE9BQXlCO0FBQUksUUFDMUMsT0FBTztBQUNYLFlBQU0sUUFBUSxFQUFFLFNBQVM7QUFDekIsWUFBTSxTQUFTLEVBQUU7QUFDakIsZ0JBQVE7QUFDUixvQkFBVSxPQUFPLEVBQUUsaUJBQWlCO0FBQ3BDLG9CQUFVLFFBQVEsRUFBRSxjQUFjO0FBQ2xDLG9CQUFVLEtBQUssRUFBRSxJQUFJO0FBQ3JCLGlCQUFTO0FBQ1QsZ0JBQVEsT0FBTyxDQUFDLGtCQUFrQixJQUFJO0FBQ3RDLG9CQUFVLE9BQU8sRUFBRSxXQUFXO0FBQzlCLG9CQUFVLFFBQVEsRUFBRSxPQUFPLENBQUMsTUFBTTtBQUNsQyxpQkFBUztBQUNULGdCQUFRLGdCQUFnQjtBQUN4QixhQUFPO0FBQ1AsU0FBSyxDQUFDO0FBQ04sSUFBRSxDQUFDO0FBQ0g7cUNBMUJDLFFBQVE7OzJEQUNQO0FBQUM7QUFDVSxZQUF1QyxTQUFTLHVCQUE5QyxRQUFRLFlBQUksUUFBUTtBQUFNOzs7Ozs7O2tDQUFFO0FBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBOZ01vZHVsZSxcbiAgTW9kdWxlV2l0aFByb3ZpZGVycyxcbiAgT3B0aW9uYWwsXG4gIFNraXBTZWxmLFxuICBQcm92aWRlcixcbn0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCB7IEh0dHBSZXF1ZXN0LCBIVFRQX0lOVEVSQ0VQVE9SUyB9IGZyb20gXCJAYW5ndWxhci9jb21tb24vaHR0cFwiO1xuaW1wb3J0IHsgSnd0SW50ZXJjZXB0b3IgfSBmcm9tIFwiLi9qd3QuaW50ZXJjZXB0b3JcIjtcbmltcG9ydCB7IEpXVF9PUFRJT05TIH0gZnJvbSBcIi4vand0b3B0aW9ucy50b2tlblwiO1xuaW1wb3J0IHsgSnd0SGVscGVyU2VydmljZSB9IGZyb20gXCIuL2p3dGhlbHBlci5zZXJ2aWNlXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSnd0Q29uZmlnIHtcbiAgdG9rZW5HZXR0ZXI/OiAoXG4gICAgcmVxdWVzdD86IEh0dHBSZXF1ZXN0PGFueT5cbiAgKSA9PiBzdHJpbmcgfCBudWxsIHwgUHJvbWlzZTxzdHJpbmcgfCBudWxsPjtcbiAgaGVhZGVyTmFtZT86IHN0cmluZztcbiAgYXV0aFNjaGVtZT86IHN0cmluZyB8ICgocmVxdWVzdD86IEh0dHBSZXF1ZXN0PGFueT4pID0+IHN0cmluZyk7XG4gIGFsbG93ZWREb21haW5zPzogQXJyYXk8c3RyaW5nIHwgUmVnRXhwPjtcbiAgZGlzYWxsb3dlZFJvdXRlcz86IEFycmF5PHN0cmluZyB8IFJlZ0V4cD47XG4gIHRocm93Tm9Ub2tlbkVycm9yPzogYm9vbGVhbjtcbiAgc2tpcFdoZW5FeHBpcmVkPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBKd3RNb2R1bGVPcHRpb25zIHtcbiAgand0T3B0aW9uc1Byb3ZpZGVyPzogUHJvdmlkZXI7XG4gIGNvbmZpZz86IEp3dENvbmZpZztcbn1cblxuQE5nTW9kdWxlKClcbmV4cG9ydCBjbGFzcyBKd3RNb2R1bGUge1xuICBjb25zdHJ1Y3RvcihAT3B0aW9uYWwoKSBAU2tpcFNlbGYoKSBwYXJlbnRNb2R1bGU6IEp3dE1vZHVsZSkge1xuICAgIGlmIChwYXJlbnRNb2R1bGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJKd3RNb2R1bGUgaXMgYWxyZWFkeSBsb2FkZWQuIEl0IHNob3VsZCBvbmx5IGJlIGltcG9ydGVkIGluIHlvdXIgYXBwbGljYXRpb24ncyBtYWluIG1vZHVsZS5cIlxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGZvclJvb3Qob3B0aW9uczogSnd0TW9kdWxlT3B0aW9ucyk6IE1vZHVsZVdpdGhQcm92aWRlcnM8Snd0TW9kdWxlPiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5nTW9kdWxlOiBKd3RNb2R1bGUsXG4gICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAge1xuICAgICAgICAgIHByb3ZpZGU6IEhUVFBfSU5URVJDRVBUT1JTLFxuICAgICAgICAgIHVzZUNsYXNzOiBKd3RJbnRlcmNlcHRvcixcbiAgICAgICAgICBtdWx0aTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgb3B0aW9ucy5qd3RPcHRpb25zUHJvdmlkZXIgfHwge1xuICAgICAgICAgIHByb3ZpZGU6IEpXVF9PUFRJT05TLFxuICAgICAgICAgIHVzZVZhbHVlOiBvcHRpb25zLmNvbmZpZyxcbiAgICAgICAgfSxcbiAgICAgICAgSnd0SGVscGVyU2VydmljZSxcbiAgICAgIF0sXG4gICAgfTtcbiAgfVxufVxuIl19